{
	"name": "Компетентность в сфере Java-разработки",
    "questions": [
        {
			"question": "Какое из следующих утверждений верно описывает проблему, связанную с инициализацией статических блоков в Java и порядком загрузки классов, которая может привести к ошибке `ExceptionInInitializerError`?",
            "type": "single",
			"points": 1,
            "options": [
				"Статические блоки выполняются всегда после конструктора класса.",
				"Порядок выполнения статических блоков родительского и дочернего классов не определен и может меняться.",
				"Ошибка в статическом блоке приводит к ошибке компиляции, а не времени выполнения.",
				"Статические блоки выполняются только после создания первого экземпляра класса.",
				"Ошибка в статическом блоке во время инициализации класса может привести к `ExceptionInInitializerError`, делая класс непригодным для использования."
			],
			"correct_answer": [
				"Ошибка в статическом блоке во время инициализации класса может привести к `ExceptionInInitializerError`, делая класс непригодным для использования."
			]
		},
		{
			"question": "Какое из следующих утверждений правильно описывает работу `ExecutorService` в Java для управления асинхронными задачами?",
            "type": "single",
			"points": 1,
            "options": [
				"`ExecutorService` гарантирует выполнение задач строго в порядке их добавления, используя один поток.",
				"`ExecutorService` предоставляет пул потоков для асинхронного выполнения задач, абстрагируя управление потоками от разработчика.",
				"Все задачи, отправленные в `ExecutorService`, автоматически выполняются с наивысшим приоритетом.",
				"`ExecutorService` предназначен исключительно для выполнения очень короткоживущих задач.",
				"После вызова `shutdown()` на `ExecutorService` он немедленно останавливает все активные задачи."
			],
			"correct_answer": [
				"`ExecutorService` предоставляет пул потоков для асинхронного выполнения задач, абстрагируя управление потоками от разработчика."
			]
		},
		{
			"question": "Какой из следующих подходов в Java наилучшим образом помогает управлять сложными цепочками асинхронных операций, избегая аналога 'callback hell'?",
            "type": "single",
			"points": 1,
            "options": [
				"Использование глубоко вложенных анонимных классов, реализующих `Runnable`.",
				"Применение `CompletableFuture` и его методов композиции (например, `thenApply`, `thenCompose`).",
				"Ручное создание и управление отдельным `Thread` для каждой асинхронной операции.",
				"Использование `synchronized` блоков для координации всех асинхронных вызовов.",
				"Применение `wait()` и `notifyAll()` на общем объекте-мониторе для всех этапов операции."
			],
			"correct_answer": [
				"Применение `CompletableFuture` и его методов композиции (например, `thenApply`, `thenCompose`)."
			]
		},
		{
			"question": "Какой из следующих методов интерфейса `java.util.stream.Stream` используется для преобразования каждого элемента стрима в другой объект?",
            "type": "single",
			"points": 1,
            "options": [
				"`filter(Predicate<T> predicate)`",
				"`forEach(Consumer<T> action)`",
				"`map(Function<T, R> mapper)`",
				"`reduce(BinaryOperator<T> accumulator)`",
				"`collect(Collector<T, A, R> collector)`"
			],
			"correct_answer": [
				"`map(Function<T, R> mapper)`"
			]
		},
		{
			"question": "В контексте паттерна Singleton в Java, какое утверждение является ключевым для его корректной реализации?",
            "type": "single",
			"points": 1,
            "options": [
				"Класс должен иметь только публичные конструкторы.",
				"Класс должен гарантировать существование только одного своего экземпляра и предоставлять глобальную точку доступа к нему.",
				"Класс должен быть объявлен как `abstract`.",
				"Каждый вызов статического метода доступа должен создавать новый экземпляр.",
				"Класс должен обязательно реализовывать интерфейс `Cloneable`."
			],
			"correct_answer": [
				"Класс должен гарантировать существование только одного своего экземпляра и предоставлять глобальную точку доступа к нему."
			]
		},
		{
			"question": "Какое из этих значений НЕ может быть присвоено переменной типа `byte` в Java без явного приведения типа или ошибки компиляции?",
            "type": "single",
			"points": 1,
            "options": [
				"127",
				"0",
				"-128",
				"128",
				"-1"
			],
			"correct_answer": [
				"128"
			]
		},
		{
			"question": "Как в Java коде обозначается однострочный комментарий?",
            "type": "single",
			"points": 1,
            "options": [
				"`/* Это комментарий */`",
				"`# Это комментарий`",
				"`// Это комментарий`",
				"`<!-- Это комментарий -->`",
				"`''' Это комментарий '''`"
			],
			"correct_answer": [
				"`// Это комментарий`"
			]
		},
		{
			"question": "Какой метод интерфейса `java.util.Collection` используется для добавления всех элементов из другой коллекции в текущую?",
            "type": "single",
			"points": 1,
            "options": [
				"`mergeAll(Collection c)`",
				"`putAll(Collection c)`",
				"`addAll(Collection c)`",
				"`insertAll(Collection c)`",
				"`append(Collection c)`"
			],
			"correct_answer": [
				"`addAll(Collection c)`"
			]
		},
		{
			"question": "Какое основное ограничение накладывает модификатор `final` на класс в Java?",
            "type": "single",
			"points": 1,
            "options": [
				"Все методы этого класса автоматически становятся `final`.",
				"От этого класса нельзя наследовать.",
				"Экземпляры этого класса становятся неизменяемыми (immutable) автоматически.",
				"Класс может содержать только статические методы.",
				"Объекты этого класса не могут быть сериализованы."
			],
			"correct_answer": [
				"От этого класса нельзя наследовать."
			]
		},
		{
			"question": "Что означает акроним 'JDK' в контексте Java?",
            "type": "single",
			"points": 1,
            "options": [
				"Java Development Kit - Набор для разработки на Java.",
				"Java Dynamic Kernel - Динамическое ядро Java.",
				"Java Deployment Kit - Набор для развертывания Java-приложений.",
				"Java Debugging Kit - Набор для отладки Java.",
				"Java Distributed Kernel - Распределенное ядро Java."
			],
			"correct_answer": [
				"Java Development Kit - Набор для разработки на Java."
			]
		},
		{
			"question": "Какие параметры обычно требуются для конструктора класса `java.io.FileInputStream` для успешного создания объекта?",
            "type": "single",
			"points": 1,
            "options": [
				"Только имя файла в виде строки.",
				"Объект `File` или строковый путь к файлу.",
				"Имя файла и режим открытия (например, 'read-only').",
				"Объект `FileDescriptor` и начальный размер буфера.",
				"URL файла и учетные данные для доступа."
			],
			"correct_answer": [
				"Объект `File` или строковый путь к файлу."
			]
		},
		{
			"question": "При создании объекта `java.util.ArrayList` с помощью конструктора `ArrayList(int initialCapacity)`, что означает параметр `initialCapacity`?",
            "type": "single",
			"points": 1,
            "options": [
				"Максимально допустимое количество элементов в списке.",
				"Начальное количество элементов, которыми будет заполнен список.",
				"Начальный размер внутреннего массива, используемого для хранения элементов.",
				"Количество элементов, на которое список будет увеличиваться при нехватке места.",
				"Идентификатор версии списка для сериализации."
			],
			"correct_answer": [
				"Начальный размер внутреннего массива, используемого для хранения элементов."
			]
		},
		{
			"question": "Что означает акроним 'JCP' в экосистеме Java?",
            "type": "single",
			"points": 1,
            "options": [
				"Java Code Perfectionists",
				"Java Cryptography Protocol",
				"Java Community Process",
				"Java Compilation Platform",
				"Joint Collaboration Program"
			],
			"correct_answer": [
				"Java Community Process"
			]
		},
		{
			"question": "Какой из перечисленных этапов НЕ является частью типичного жизненного цикла разработки программного обеспечения (SDLC)?",
            "type": "single",
			"points": 1,
            "options": [
				"Сбор и анализ требований",
				"Проектирование",
				"Разработка (кодирование)",
				"Тестирование",
				"Единоличное утверждение главным архитектором без согласования"
			],
			"correct_answer": [
				"Единоличное утверждение главным архитектором без согласования"
			]
		},
		{
			"question": "В Java, официальное описание синтаксиса и семантики языка, а также стандартных библиотек, содержится в каком документе?",
            "type": "single",
			"points": 1,
            "options": [
				"В Javadoc-комментариях к каждому классу стандартной библиотеки.",
				"В официальных учебниках и руководствах от Oracle Press.",
				"В Спецификации языка Java (Java Language Specification - JLS) и Спецификации Виртуальной Машины Java (JVM Specification).",
				"В wiki-документации проекта OpenJDK.",
				"В сборнике статей, публикуемых в рамках Java Community Process (JCP)."
			],
			"correct_answer": [
				"В Спецификации языка Java (Java Language Specification - JLS) и Спецификации Виртуальной Машины Java (JVM Specification)."
			]
		},
		{
			"question": "Какой класс из стандартной библиотеки Java (например, из пакета `java.awt.image`) может быть использован для применения операции свертки (convolution), такой как размытие, к изображению?",
            "type": "single",
			"points": 1,
            "options": [
				"`ImageFilter`",
				"`ConvolveOp` (реализация `BufferedImageOp`)",
				"`PixelGrabber`",
				"`ImageBlurrer` (не существует в стандартной библиотеке)",
				"`Graphics.blurEffect()` (не существует в стандартной библиотеке)"
			],
			"correct_answer": [
				"`ConvolveOp` (реализация `BufferedImageOp`)"
			]
		},
		{
			"question": "Какой из следующих языков программирования или концепций оказал значительное влияние на введение лямбда-выражений в Java 8?",
            "type": "single",
			"points": 1,
            "options": [
				"C++ (через указатели на функции)",
				"Python (через list comprehensions)",
				"Функциональные языки, такие как Lisp и Scala (концепция функций первого класса и замыканий).",
				"PHP (через анонимные функции)",
				"Visual Basic (через делегаты)"
			],
			"correct_answer": [
				"Функциональные языки, такие как Lisp и Scala (концепция функций первого класса и замыканий)."
			]
		},
		{
			"question": "Что представляет собой интерфейс `java.util.concurrent.Future<V>` в Java?",
            "type": "single",
			"points": 1,
            "options": [
				"Объект, гарантирующий немедленное выполнение задачи.",
				"Объект, представляющий результат асинхронной операции, который может быть еще не доступен.",
				"Механизм для создания задач, выполняемых по строгому расписанию.",
				"Интерфейс для управления жизненным циклом потоков напрямую.",
				"Коллекция, хранящая результаты всех завершенных асинхронных задач."
			],
			"correct_answer": [
				"Объект, представляющий результат асинхронной операции, который может быть еще не доступен."
			]
		},
		{
			"question": "Какой из следующих подходов НЕ является рекомендуемым способом уменьшения потребления памяти в Java-приложении без изменения его основной функциональности?",
            "type": "single",
			"points": 1,
            "options": [
				"Использование более эффективных структур данных для конкретной задачи.",
				"Профилирование приложения для выявления и устранения утечек памяти.",
				"Оптимизация создания объектов, избегание избыточных аллокаций.",
				"Значительное увеличение максимального размера кучи (heap size) с помощью опции `-Xmx` без анализа причин потребления.",
				"Использование примитивных типов вместо их классов-оберток там, где это возможно и уместно."
			],
			"correct_answer": [
				"Значительное увеличение максимального размера кучи (heap size) с помощью опции `-Xmx` без анализа причин потребления."
			]
		},
		{
			"question": "Если у вас есть `ArrayList<Integer>` в Java, который содержит много элементов, но затем большинство из них удаляется, какой метод следует вызвать, чтобы освободить неиспользуемую память, занимаемую внутренним массивом списка?",
            "type": "single",
			"points": 1,
            "options": [
				"`arrayList.clear()` (это удалит все элементы, а не только освободит память)",
				"`arrayList.compact()` (такого метода нет)",
				"`arrayList.trimToSize()`",
				"`arrayList.resize(newSize)` (такого метода нет)",
				"`System.gc()` (не гарантирует немедленного освобождения и не специфичен для ArrayList)"
			],
			"correct_answer": [
				"`arrayList.trimToSize()`"
			]
		},
		{
			"question": "Выберите верное утверждение о ключевом слове `static` в Java применительно к членам класса:",
            "type": "single",
			"points": 1,
            "options": [
				"Статические методы могут напрямую обращаться к нестатическим (instance) полям класса.",
				"Каждый экземпляр класса имеет свою собственную копию статического поля.",
				"Статические поля и методы принадлежат классу, а не конкретному экземпляру класса.",
				"Статические методы не могут быть вызваны с использованием имени класса (например, `MyClass.staticMethod()`).",
				"Ключевое слово `static` можно применять к локальным переменным внутри метода."
			],
			"correct_answer": [
				"Статические поля и методы принадлежат классу, а не конкретному экземпляру класса."
			]
		},
		{
			"question": "Какой метод интерфейса `java.util.Map<K, V>` используется для получения значения, связанного с указанным ключом?",
            "type": "single",
			"points": 1,
            "options": [
				"`map.fetch(key)`",
				"`map.select(key)`",
				"`map.get(key)`",
				"`map.query(key)`",
				"`map.retrieve(key)`"
			],
			"correct_answer": [
				"`map.get(key)`"
			]
		},
		{
			"question": "Что необходимо написать в цикле для изменения свойства `active` (логического типа) каждого объекта `User` в списке `List<User> users` на `true`, предполагая, что у класса `User` есть метод `setActive(boolean isActive)`?",
			"code_template": "// List<User> users = ...;\n// for (User user : users) {\n//     // Ваш код\n// }",
            "type": "single",
			"points": 1,
            "options": [
				"`user.active = true;` (если поле `active` публичное)",
				"`user.setActive(true);`",
				"`User.setActive(user, true);`",
				"`users.update(user, u -> u.setActive(true));`",
				"`SET user.active = true;`"
			],
			"correct_answer": [
				"`user.setActive(true);`"
			]
		},
		{
			"question": "Какой из следующих принципов НЕ является одним из четырех основных принципов объектно-ориентированного программирования (ООП), широко используемых в Java?",
            "type": "single",
			"points": 1,
            "options": [
				"Инкапсуляция",
				"Наследование",
				"Полиморфизм",
				"Абстракция",
				"Функциональная декомпозиция (это принцип процедурного программирования)"
			],
			"correct_answer": [
				"Функциональная декомпозиция (это принцип процедурного программирования)"
			]
		},
		{
			"question": "Какой класс из стандартной библиотеки Java (например, из пакета `java.awt.image`) может быть использован для применения операции свертки (convolution), такой как размытие, к изображению?",
            "type": "single",
			"points": 1,
            "options": [
				"`ImageFilter`",
				"`ConvolveOp` (реализация `BufferedImageOp`)",
				"`PixelGrabber`",
				"`ImageBlurrer` (не существует в стандартной библиотеке)",
				"`Graphics.blurEffect()` (не существует в стандартной библиотеке)"
			],
			"correct_answer": [
				"`ConvolveOp` (реализация `BufferedImageOp`)"
			]
		},
		{
			"question": "Является ли язык программирования Java чувствительным к регистру при написании идентификаторов (имен переменных, методов, классов)?",
            "type": "single",
			"points": 1,
            "options": [
				"Да, Java строго чувствителен к регистру для всех идентификаторов.",
				"Нет, Java не чувствителен к регистру.",
				"Только имена классов чувствительны к регистру, остальные идентификаторы - нет.",
				"Чувствительность к регистру зависит от операционной системы, на которой выполняется JVM.",
				"Только ключевые слова чувствительны к регистру."
			],
			"correct_answer": [
				"Да, Java строго чувствителен к регистру для всех идентификаторов."
			]
		},
		{
			"question": "Какие из следующих утверждений являются верными относительно обработки исключений (exceptions) в Java?",
			"type": "multiple",
			"points": 1,
            "options": [
				"Блок `finally` выполняется всегда, если только не произошел вызов `System.exit()` или критическая ошибка JVM.",
				"Не рекомендуется перехватывать `java.lang.Error` и его подклассы, так как они обычно сигнализируют о невосстановимых ошибках.",
				"Все исключения в Java должны быть явно объявлены в сигнатуре метода с помощью `throws`.",
				"Можно создавать собственные классы исключений, наследуясь от `Exception` (для проверяемых) или `RuntimeException` (для непроверяемых).",
				"Блок `try` может существовать без блока `catch`, если есть блок `finally`."
			],
			"correct_answer": [
				"Блок `finally` выполняется всегда, если только не произошел вызов `System.exit()` или критическая ошибка JVM.",
				"Не рекомендуется перехватывать `java.lang.Error` и его подклассы, так как они обычно сигнализируют о невосстановимых ошибках.",
				"Можно создавать собственные классы исключений, наследуясь от `Exception` (для проверяемых) или `RuntimeException` (для непроверяемых).",
				"Блок `try` может существовать без блока `catch`, если есть блок `finally`."
			]
		},
		{
			"question": "Какие из перечисленных являются типами методов или конструкций, выполняющих роль методов (или их частей) в языке Java?",
            "type": "multiple",
			"points": 1,
            "options": [
				"Статические методы (Static methods)",
				"Методы экземпляра (Instance methods)",
				"Конструкторы (Constructors)",
				"Абстрактные методы (Abstract methods)",
				"Лямбда-выражения (как реализации функциональных интерфейсов)"
            ],
            "correct_answer": [
				"Статические методы (Static methods)",
				"Методы экземпляра (Instance methods)",
				"Конструкторы (Constructors)",
				"Абстрактные методы (Abstract methods)",
				"Лямбда-выражения (как реализации функциональных интерфейсов)"
			]
		},
		{
			"question": "При разработке серверной части (backend) для интернет-магазина, где требуется обеспечить переход от корзины к оформлению заказа без обновления всей страницы клиентом, какой ключевой архитектурный подход или набор технологий со стороны сервера вы бы применили для поддержки таких AJAX-взаимодействий? Кратко опишите его суть.",
			"type": "open",
			"points": 1,
			"correct_answer_description": "Использование RESTful API. Сервер предоставляет эндпоинты (например, /api/cart, /api/checkout), которые принимают HTTP-запросы (GET, POST, PUT, DELETE) и возвращают данные, как правило, в формате JSON. Клиентское приложение (фронтенд) асинхронно обращается к этим API для получения, отправки и обновления данных, а затем динамически изменяет отображение на странице без полной перезагрузки. Фреймворки типа Spring MVC/Boot с аннотациями @RestController упрощают создание таких API."
		},
		{
			"question": "Заказчик просит реализовать в Java-приложении сложную бизнес-логику, которая требует частого изменения правил без перекомпиляции и перезапуска приложения. Ваши коллеги предлагают жестко закодировать всю логику. Какой альтернативный подход или технологию вы бы предложили для обеспечения гибкости и возможности обновления правил 'на лету'?",
			"type": "open",
			"points": 1,
			"correct_answer_description": "Можно предложить использование движка правил (Rules Engine), такого как Drools, Jess или Easy Rules. Это позволит вынести бизнес-правила во внешние файлы (например, DRL для Drools) или специализированный DSL. Эти правила можно будет изменять и динамически загружать в приложение без его остановки и перекомпиляции, что обеспечит требуемую гибкость и быстрое обновление логики."
		},
		{
			"question": "Клиент предлагает использовать для нового Java-проекта малоизвестный фреймворк X, который обещает высокую производительность, но имеет небольшое сообщество и ограниченную документацию. Ваши коллеги настаивают на использовании проверенного временем Spring Boot. Какие ключевые аргументы вы приведете клиенту, сравнивая риски и преимущества, чтобы помочь принять взвешенное решение?",
			"type": "open",
			"points": 1,
			"correct_answer_description": "Следует объективно сравнить: \nРиски фреймворка X: малое сообщество означает сложный поиск помощи и разработчиков; ограниченная документация увеличивает время на обучение и решение проблем; возможные баги и отсутствие долгосрочной поддержки; зависимость от небольшого числа разработчиков фреймворка. \nПреимущества Spring Boot: огромное сообщество, обширная документация, множество готовых решений и интеграций, стабильность, большое количество квалифицированных разработчиков, проверенность в промышленных проектах. \nОбсудить с клиентом критичность проекта, сроки, бюджет, требования к надежности и готовность к технологическим рискам. Возможно, для небольшого некритичного проекта или прототипа фреймворк X приемлем, но для крупного и долгосрочного — риски могут перевесить."
		},
		{
			"question": "Один из старших разработчиков утверждает, что для повышения производительности Java-приложения следует всегда избегать создания новых объектов в циклах и максимально переиспользовать существующие, даже если это значительно усложняет код и его читаемость. Согласны ли вы с этим утверждением без оговорок? Объясните свою позицию, упомянув работу сборщика мусора (GC) и важность поддержки кода.",
            "type": "open",
			"points": 1,
			"correct_answer_description": "Не согласен без оговорок. Хотя чрезмерное создание короткоживущих объектов в очень частых циклах действительно может создавать дополнительную нагрузку на сборщик мусора, современные JVM и GC (особенно G1, ZGC, Shenandoah) очень эффективны в обработке таких объектов. Полный отказ от создания объектов в угоду агрессивному переиспользованию часто приводит к: \n1. Усложнению кода, делая его менее читаемым и сложным для поддержки.  \n2. Увеличению вероятности ошибок из-за управления сложным состоянием переиспользуемых объектов.  \n3. Преждевременной оптимизации, которая может не дать значительного выигрыша, но ухудшит качество кода.  \nВажен баланс: следует профилировать приложение для выявления реальных узких мест производительности. Если создание объектов в конкретном цикле действительно является проблемой, тогда стоит рассмотреть оптимизации. В остальных случаях читаемость и поддерживаемость кода часто важнее микрооптимизаций."
        },
        {
			"question": "Как называется стандартный публичный статический метод, который служит точкой входа для выполнения консольного Java-приложения?",
            "type": "open",
			"points": 2,
			"correct_answer_description": "Метод `main`. Полная сигнатура: `public static void main(String[] args)` или `public static void main(String... args)`."
        },
        {
			"question": "Назовите две основные области памяти в JVM, где преимущественно размещаются объекты, создаваемые во время выполнения Java-приложения, и метаданные классов.",
            "type": "open",
			"points": 2,
			"correct_answer_description": "1. Куча (Heap) - для хранения экземпляров объектов и массивов. \n2. Область методов (Method Area) / Metaspace (начиная с Java 8) - для хранения метаданных классов, пула строк, статических переменных."
        },
        {
			"question": "Если в классе `com.example.Utility` есть публичный статический метод `void processData()`, как его корректно вызвать из другого класса (например, `Main`)?",
            "type": "open",
			"points": 2,
			"correct_answer_description": "`com.example.Utility.processData();` (если класс `Utility` не импортирован статически) или `Utility.processData();` (если класс `Utility` импортирован или находится в том же пакете и доступен, или если есть статический импорт метода)."
        },
        {
			"question": "Используя статический метод класса `java.lang.Math`, найдите максимальное значение двух целочисленных переменных `a` и `b`. В поле ответа впишите только вызов этого метода.",
            "type": "open",
			"points": 2,
			"correct_answer_description": "`Math.max(a, b)`"
        },
        {
			"question": "В Java Swing, какой стандартный LayoutManager позволяет располагать компоненты в одну строку (горизонтально) или в один столбец (вертикально), учитывая их предпочтительные размеры?",
            "type": "open",
			"points": 2,
			"correct_answer_description": "`BoxLayout` (или `FlowLayout` для простого последовательного расположения в строке с переносом)."
        },
        {
			"question": "Назовите основные способы создания потоков в Java?",
            "type": "open",
			"points": 2,
			"correct_answer_description": "1. Реализация интерфейса Runnable и передача его в конструктор Thread. \n2. Наследование от класса Thread и переопределение метода run().\n3. Использование ExecutorService из пакета java.util.concurrent.\n4. Реализация интерфейса Callable<V> для возврата результата."
        },
        {
			"question": "Используя статический метод класса `java.lang.Math`, найдите максимальное значение двух целочисленных переменных `a` и `b`. В поле ответа впишите только вызов этого метода.",
            "type": "open",
			"points": 1,
			"correct_answer_description": "`Math.max(a, b)`"
        },
        {
			"question": "Дан массив `int[] numbers`, содержащий все числа от 1 до N (включительно, N >= 1) в произвольном порядке, за исключением одного пропущенного числа. Напишите Java-метод `public static int findMissingNumber(int[] numbers, int nLimit)` который находит это пропущенное число. Предполагается, что массив содержит N-1 уникальных чисел из диапазона [1, N].",
            "type": "code",
			"points": 5,
			"correct_answer_description": "Одно из решений - использовать сумму арифметической прогрессии. Ожидаемая сумма чисел от 1 до N вычисляется как `N * (N + 1) / 2`. Фактическая сумма элементов в массиве вычисляется простым суммированием. Разница между ожидаемой и фактической суммой и будет искомым числом.\n```java\npublic class Solution {\n    public static int findMissingNumber(int[] numbers, int nLimit) {\n        if (nLimit <= 0) return 0; // или выбросить исключение\n        long expectedSum = (long)nLimit * (nLimit + 1) / 2;\n        long actualSum = 0;\n        for (int num : numbers) {\n            actualSum += num;\n        }\n        return (int)(expectedSum - actualSum);\n    }\n}```"
		},
		{
			"question": "Проверьте следующие фрагменты Java-кода. Если код работает некорректно согласно описанию, исправьте ошибки и предоставьте правильный вариант вместе с пояснениями.\n1. Код должен был вывести в консоль число 1, но выводит 0:\n   ```java\n   // int a = 0;\n   // System.out.println(a++); \n   ```\n2. Код должен вывести первую цифру положительного целого числа (например, для 123 это 1):\n   ```java\n   // int num = 123;\n   // // Предполагается, что программист хотел получить первую цифру как число\n   // String s = Integer.toString(num);\n   // System.out.println(s.charAt(0)); // Это выведет символ '1'\n   ```\n3. Код должен вывести количество цифр в положительном целом числе (например, для 123 это 3):\n   ```java\n   // int num = 123;\n   // String strNum = Integer.toString(num);\n   // System.out.println(strNum.lenght); // Опечатка в названии метода\n   ```",
            "type": "code",
			"points": 5,
			"correct_answer_description": "1. **Проблема:** Постфиксный инкремент `a++` сначала возвращает текущее значение `a` (которое равно 0) для использования в `System.out.println()`, и только потом увеличивает `a` до 1.\n **Исправление:** Использовать префиксный инкремент `++a` или вывести `a` после инкремента.\n ```java\n // Вариант 1:\n int a1 = 0;\n System.out.println(++a1); // Выведет 1\n // Вариант 2:\n int a2 = 0;\n a2++;\n System.out.println(a2); // Выведет 1\n ``\n\n2. **Проблема:** `s.charAt(0)` возвращает символ (тип `char`), а не числовое значение первой цифры. Для числа `123` это будет символ `'1'`, а не число `1`.\n  **Исправление:** Преобразовать символ в числовое значение или использовать математический подход.\n  ```java\n  // Вариант 1 (получение числового значения из символа):\n  int num1 = 123;\n  String s1 = Integer.toString(num1);\n  System.out.println(Character.getNumericValue(s1.charAt(0))); // Выведет 1\n\n  // Вариант 2 (математический, для положительных чисел):\n  int num2 = 123;\n  if (num2 < 0) num2 = -num2; // Обработка отрицательных, если нужно\n  if (num2 == 0) {\n      System.out.println(0);\n  } else {\n      int firstDigit = num2;\n      while (firstDigit >= 10) {\n          firstDigit /= 10;\n      }\n      System.out.println(firstDigit); // Выведет 1\n  }\n  ```\n\n3. **Проблема:** Опечатка в слове `length`. В Java для получения длины строки используется метод `length()`.\n  **Исправление:** Заменить `lenght` на `length()`.\n  ```java\n  int num3 = 123;\n  String strNum3 = Integer.toString(num3);\n  System.out.println(strNum3.length()); // Выведет 3\n  ```"
		},
		{
			"question": "Какой метод интерфейса `java.util.Collection` используется для добавления всех элементов из другой коллекции в текущую?",
			"type": "single",
			"points": 1,
			"options": [
				"`mergeAll(Collection c)`",
				"`putAll(Collection c)`",
				"`addAll(Collection c)`",
				"`insertAll(Collection c)`",
				"`append(Collection c)`"
			],
			"correct_answer": [
				"`addAll(Collection c)`"
			]
        }
    ]
} 